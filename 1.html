<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 流体光轨效果</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            min-height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            text-align: center;
            pointer-events: none;
            width: 90%;
            max-width: 800px;
        }

        h1 {
            font-size: clamp(2.5rem, 5vw, 4rem);
            font-weight: 800;
            margin-bottom: 1.5rem;
            letter-spacing: -0.02em;
            opacity: 0.9;
        }

        h1 .gradient-text {
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            display: inline-block;
        }

        p {
            font-size: clamp(1rem, 2vw, 1.2rem);
            line-height: 1.6;
            margin-bottom: 2rem;
            color: rgba(255, 255, 255, 0.7);
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .controls {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 2rem;
            pointer-events: all;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: white;
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .control-btn.active {
            background: rgba(78, 205, 196, 0.25);
            border-color: rgba(78, 205, 196, 0.5);
        }

        .fps-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 15px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9rem;
            z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            z-index: 10;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            max-width: 90%;
        }

        .particle-count {
            margin-top: 1rem;
            font-size: 0.95rem;
            color: rgba(255, 255, 255, 0.6);
        }

        @media (max-width: 768px) {
            .content {
                width: 95%;
            }
            
            .controls {
                gap: 8px;
            }
            
            .control-btn {
                padding: 8px 16px;
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="content">
        <h1><span class="gradient-text">Three.js 流体光轨</span></h1>
        <p>移动鼠标或手指来体验 Three.js 创建的交互式流体粒子效果。通过调整参数，你可以改变视觉效果和交互体验。</p>
        
        <div class="controls">
            <button id="toggle-trail" class="control-btn active">启用拖尾</button>
            <button id="color-mode" class="control-btn">单色模式</button>
            <button id="add-intensity" class="control-btn">增强强度</button>
            <button id="reset-effect" class="control-btn">重置效果</button>
        </div>
        
        <div class="particle-count">
            粒子数量: <span id="count">5000</span>
        </div>
    </div>
    
    <div class="fps-counter">FPS: 60</div>
    <div class="instructions">移动鼠标/手指探索效果 | 点击按钮切换模式</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 初始化 Three.js 场景
        let scene, camera, renderer;
        let particleSystem;
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        
        // 效果参数
        let effectParams = {
            trailEnabled: true,
            colorMode: 'colorful', // 'colorful' 或 'monochrome'
            intensity: 1.0,
            particleCount: 5000,
            mouseRadius: 200,
            attractionForce: 0.02,
            repulsionForce: 0.01
        };
        
        // 存储粒子数据
        let particles = {
            positions: null,
            originalPositions: null,
            velocities: null,
            colors: null,
            targetColors: null
        };
        
        // 颜色配置
        const colors = [
            new THREE.Color(0xff6b6b), // 红色
            new THREE.Color(0x4ecdc4), // 青色
            new THREE.Color(0x45b7d1), // 蓝色
            new THREE.Color(0x96ceb4), // 绿色
            new THREE.Color(0xfeca57)  // 黄色
        ];
        
        // 初始化函数
        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // 创建粒子系统
            createParticles();
            
            // 添加光线效果
            addLighting();
            
            // 事件监听
            setupEventListeners();
            
            // 开始动画循环
            animate();
        }
        
        // 创建粒子系统
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(effectParams.particleCount * 3);
            const originalPositions = new Float32Array(effectParams.particleCount * 3);
            const particleColors = new Float32Array(effectParams.particleCount * 3);
            const velocities = new Float32Array(effectParams.particleCount * 3);
            const targetColors = new Float32Array(effectParams.particleCount * 3);
            
            // 初始化粒子位置、颜色和速度
            for (let i = 0; i < effectParams.particleCount; i++) {
                // 随机初始位置
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 100;
                positions[i3 + 1] = (Math.random() - 0.5) * 100;
                positions[i3 + 2] = (Math.random() - 0.5) * 100;
                
                // 保存原始位置（用于复位）
                originalPositions[i3] = positions[i3];
                originalPositions[i3 + 1] = positions[i3 + 1];
                originalPositions[i3 + 2] = positions[i3 + 2];
                
                // 随机速度
                velocities[i3] = (Math.random() - 0.5) * 0.05;
                velocities[i3 + 1] = (Math.random() - 0.5) * 0.05;
                velocities[i3 + 2] = (Math.random() - 0.5) * 0.05;
                
                // 随机分配颜色
                const color = colors[Math.floor(Math.random() * colors.length)];
                particleColors[i3] = color.r;
                particleColors[i3 + 1] = color.g;
                particleColors[i3 + 2] = color.b;
                
                // 目标颜色（用于颜色渐变）
                targetColors[i3] = color.r;
                targetColors[i3 + 1] = color.g;
                targetColors[i3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            
            // 创建材质
            const material = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            // 创建粒子系统
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // 保存粒子数据
            particles.positions = positions;
            particles.originalPositions = originalPositions;
            particles.velocities = velocities;
            particles.colors = particleColors;
            particles.targetColors = targetColors;
            particles.geometry = geometry;
            
            // 更新粒子数量显示
            document.getElementById('count').textContent = effectParams.particleCount;
        }
        
        // 添加光照
        function addLighting() {
            // 环境光
            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);
            
            // 点光源
            const pointLight = new THREE.PointLight(0xffffff, 0.5);
            pointLight.position.set(50, 50, 50);
            scene.add(pointLight);
        }
        
        // 更新粒子
        function updateParticles() {
            const positions = particles.positions;
            const originalPositions = particles.originalPositions;
            const velocities = particles.velocities;
            const colors = particles.colors;
            const targetColors = particles.targetColors;
            
            if (!positions || !velocities || !colors) return;
            
            // 转换鼠标坐标到 Three.js 坐标空间
            const mouseXThree = (mouseX / window.innerWidth) * 2 - 1;
            const mouseYThree = -(mouseY / window.innerHeight) * 2 + 1;
            
            // 计算鼠标在 3D 空间中的位置
            const mouseVector = new THREE.Vector3(
                mouseXThree * 50, 
                mouseYThree * 50, 
                0
            );
            
            // 更新每个粒子
            for (let i = 0; i < effectParams.particleCount; i++) {
                const i3 = i * 3;
                
                // 粒子当前位置
                const particlePos = new THREE.Vector3(
                    positions[i3],
                    positions[i3 + 1],
                    positions[i3 + 2]
                );
                
                // 计算粒子到鼠标的距离
                const distanceToMouse = particlePos.distanceTo(mouseVector);
                
                // 鼠标影响范围内的粒子
                if (distanceToMouse < effectParams.mouseRadius) {
                    // 计算从粒子指向鼠标的向量
                    const direction = new THREE.Vector3().subVectors(mouseVector, particlePos).normalize();
                    
                    // 应用吸引力（距离越近，力越大）
                    const force = effectParams.attractionForce * (1 - distanceToMouse / effectParams.mouseRadius);
                    
                    velocities[i3] += direction.x * force * effectParams.intensity;
                    velocities[i3 + 1] += direction.y * force * effectParams.intensity;
                    velocities[i3 + 2] += direction.z * force * effectParams.intensity;
                    
                    // 在单色模式下，根据与鼠标的距离改变粒子颜色
                    if (effectParams.colorMode === 'monochrome') {
                        const brightness = 0.5 + (1 - distanceToMouse / effectParams.mouseRadius) * 0.5;
                        colors[i3] = brightness;
                        colors[i3 + 1] = brightness;
                        colors[i3 + 2] = brightness;
                    } else {
                        // 彩色模式下，根据距离混合颜色
                        const colorIndex = Math.floor((distanceToMouse / effectParams.mouseRadius) * colors.length);
                        const color = colors[colorIndex % colors.length];
                        targetColors[i3] = color.r;
                        targetColors[i3 + 1] = color.g;
                        targetColors[i3 + 2] = color.b;
                    }
                } else {
                    // 远离鼠标的粒子恢复目标颜色
                    if (effectParams.colorMode === 'colorful') {
                        // 缓慢向目标颜色过渡
                        colors[i3] += (targetColors[i3] - colors[i3]) * 0.01;
                        colors[i3 + 1] += (targetColors[i3 + 1] - colors[i3 + 1]) * 0.01;
                        colors[i3 + 2] += (targetColors[i3 + 2] - colors[i3 + 2]) * 0.01;
                    }
                }
                
                // 应用速度阻尼
                velocities[i3] *= 0.95;
                velocities[i3 + 1] *= 0.95;
                velocities[i3 + 2] *= 0.95;
                
                // 应用边界反弹
                const boundary = 50;
                if (Math.abs(positions[i3]) > boundary) velocities[i3] *= -0.8;
                if (Math.abs(positions[i3 + 1]) > boundary) velocities[i3 + 1] *= -0.8;
                if (Math.abs(positions[i3 + 2]) > boundary) velocities[i3 + 2] *= -0.8;
                
                // 更新位置
                positions[i3] += velocities[i3];
                positions[i3 + 1] += velocities[i3 + 1];
                positions[i3 + 2] += velocities[i3 + 2];
                
                // 缓慢向原始位置回归
                if (distanceToMouse > effectParams.mouseRadius * 1.5) {
                    positions[i3] += (originalPositions[i3] - positions[i3]) * 0.005;
                    positions[i3 + 1] += (originalPositions[i3 + 1] - positions[i3 + 1]) * 0.005;
                    positions[i3 + 2] += (originalPositions[i3 + 2] - positions[i3 + 2]) * 0.005;
                }
            }
            
            // 标记位置和颜色属性需要更新
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 更新粒子
            updateParticles();
            
            // 轻微旋转整个粒子系统
            particleSystem.rotation.x += 0.0005;
            particleSystem.rotation.y += 0.001;
            
            // 渲染场景
            renderer.render(scene, camera);
            
            // 更新 FPS 显示
            updateFPS();
        }
        
        // FPS 计数器
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;
        
        function updateFPS() {
            frameCount++;
            const currentTime = performance.now();
            
            if (currentTime >= lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.querySelector('.fps-counter').textContent = `FPS: ${fps}`;
                frameCount = 0;
                lastTime = currentTime;
            }
        }
        
        // 事件监听器设置
        function setupEventListeners() {
            // 鼠标移动事件
            document.addEventListener('mousemove', onMouseMove);
            
            // 触摸移动事件（移动设备支持）
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            
            // 窗口大小调整事件
            window.addEventListener('resize', onWindowResize);
            
            // 控制按钮事件
            document.getElementById('toggle-trail').addEventListener('click', toggleTrail);
            document.getElementById('color-mode').addEventListener('click', toggleColorMode);
            document.getElementById('add-intensity').addEventListener('click', increaseIntensity);
            document.getElementById('reset-effect').addEventListener('click', resetEffect);
        }
        
        // 鼠标移动处理
        function onMouseMove(event) {
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        // 触摸移动处理
        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length > 0) {
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
            }
        }
        
        // 窗口大小调整处理
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
        }
        
        // 切换拖尾效果
        function toggleTrail() {
            effectParams.trailEnabled = !effectParams.trailEnabled;
            const btn = document.getElementById('toggle-trail');
            
            if (effectParams.trailEnabled) {
                btn.classList.add('active');
                btn.textContent = '启用拖尾';
                renderer.setClearColor(0x000000, 0);
            } else {
                btn.classList.remove('active');
                btn.textContent = '禁用拖尾';
                // 禁用拖尾时，每帧清除画布
                renderer.setClearColor(0x000000, 1);
            }
        }
        
        // 切换颜色模式
        function toggleColorMode() {
            effectParams.colorMode = effectParams.colorMode === 'colorful' ? 'monochrome' : 'colorful';
            const btn = document.getElementById('color-mode');
            
            if (effectParams.colorMode === 'monochrome') {
                btn.classList.add('active');
                btn.textContent = '彩色模式';
            } else {
                btn.classList.remove('active');
                btn.textContent = '单色模式';
            }
        }
        
        // 增加效果强度
        function increaseIntensity() {
            effectParams.intensity = Math.min(3.0, effectParams.intensity + 0.5);
            const btn = document.getElementById('add-intensity');
            
            btn.textContent = `强度: ${effectParams.intensity.toFixed(1)}`;
            
            // 3秒后恢复按钮文本
            setTimeout(() => {
                if (effectParams.intensity === 1.0) {
                    btn.textContent = '增强强度';
                } else {
                    btn.textContent = `强度: ${effectParams.intensity.toFixed(1)}`;
                }
            }, 2000);
        }
        
        // 重置效果
        function resetEffect() {
            effectParams.intensity = 1.0;
            
            // 更新按钮状态
            document.getElementById('add-intensity').textContent = '增强强度';
            document.getElementById('toggle-trail').classList.add('active');
            document.getElementById('toggle-trail').textContent = '启用拖尾';
            document.getElementById('color-mode').classList.remove('active');
            document.getElementById('color-mode').textContent = '单色模式';
            
            // 重新启用拖尾
            effectParams.trailEnabled = true;
            effectParams.colorMode = 'colorful';
            
            // 重新创建粒子系统
            scene.remove(particleSystem);
            createParticles();
        }
        
        // 启动应用
        init();
    </script>
</body>
</html>